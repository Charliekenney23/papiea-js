#+Title: Papiea Design
#+SETUPFILE: https://raw.githubusercontent.com/fniessen/org-html-themes/master/setup/theme-readtheorg.setup
#+Options: H:5

#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+HTML_HEAD: <style>#content{max-width:70%;} </style>

Papiea is aimed to be a reference implementation of a formal general purpose intent engine. 

* Definitions
  - _Spec_ - a map containing the desired state of a particular entity
  - _Status_ - a map containing the current statue of a particular entity. Always a superset of Spec
  - _Metadata_ - Information of the identity of the entity. Must contain at least =uuid=, =kind= and =specVersion=
  - _Spec version_ - an integer representing the version of the current spec. Updates to spec will =CAS= on this field
  - _Entity_ - The tuple =[Metadata, Spec, Status]=
  - _Kind_ - The "type" of the entity
  - _Diff_ - A difference between the current Status and the most recent desired Spec
  - _Providers_ - Pluggable handlers that can transform an entity from its current state to its desired state
  - _Tasks_ - a mechanism for following the progress of resolving Diffs
* Data Structures
** Spec
   Status and Spec are both unstructured, and may change at runtime (by changing providers). Go is a little afraid of
   unstructured types, so we have to be very gentle. Here is an example of how this could be achieved.
   
   First, lets declare an untyped json type:

   #+Name: untyped-json-type
   #+BEGIN_SRC go
   type untypedJson map[string]interface{}
   #+END_SRC

   Now, spec is simply an entyped_json
   #+Name: spec-struct
   #+BEGIN_SRC go
   type spec untypedJson
   #+END_SRC
** Status
   For now its strictly untyped, but there may be a better way to denote the fact that status is a super-set of spec

   #+Name: status-struct
   #+BEGIN_SRC go
   type status untypedJson
   #+END_SRC

** Metadata
   Metadata has a bit more structured then spec and status, it must have at least the following items:
   - =uuid= - a unique id representing the identity of this entity
   - =kind= - the "type" of this entity
   - =specVersion= - the most up-to-date revision of the spec associated with this entity
   #+Name: metadata-struct
   #+BEGIN_SRC go
     type metadata struct {
         uuid uuid
         kind string
         specVersion int
     }
   #+END_SRC
** Kind
   A Kind of an entity is the entity's type. It denotes the valid fields for spec and status for an instance of this kind.

   #+Name: kind-struct
   #+BEGIN_SRC go
     type kind struct {
         name string
         entityStructure untypedJson
     }
   #+END_SRC
** Provider description
   A Provider is a plugglable set of handlers, which is responsible for converging a certain entity kind. Its handlers
   are responsible to move the entity from a current status to an intended spec.
   #+Name: provider-desc-struct
   #+BEGIN_SRC go
     type providerDescription struct {
         uuid uuid
         version int
         uri string
         kinds []kind
     }
   #+END_SRC

   It has a unique identifier and a version, as well as a uri that is a logical name that will be used to access an
   instance of the provider (since there may be multiple instances with a load-balancer). For example, a uri could be:
   =https://nunet.nutanix.com/hosts=. A provider may support multiple kinds but we believe it is best practice to have
   one provider per kind.

* Modules
** Databases
   #+BEGIN_note
   *Multitenancy*: All databases are aware of tenants. It may be implemented as a column or attribute of a table or
   document, or as a different database with a different connect uri.
   #+END_note
   
*** Status
    Status database will be a mapping from a metadata (namely, =uuid= and =kind=) to a status json document. 

    It may be implemented using a very fast in-memory database, since it may require frequent access depending on an
    entity's kind requirement. It is not required to have this database persisted to disk, since its content can always
    be reacquired by the providers, by asking all the providers to list all the real statuses of all objects known to
    them.

    Each provider for a kind will supply its entity's structure in its YAML.
    
**** Interface
    #+Name: status-db-interface
    #+BEGIN_SRC go
      type statusDb interface {
          updateStatus(metadata, status) err
          getStatus(metadata) status, err
          deleteStatus(metadata) err
          cleanup() err
      }
    #+END_SRC

*** Spec
    Unlike status which can always be fetched from the providers, spec is a record of the user's intent and must be
    persisted to disk. It must also be scalable and highly available. It must have a clear notion of CAS
    (compare-and-set/swap) in order to atomically update spec values.

**** Interface
    #+Name: spec-db-interface
    #+BEGIN_SRC go
      type specDb interface {
          casSpecChange(metadata, status) task, err
          getLatestSpec(metadata) metadata, spec, err
          cleanup() err
      }
    #+END_SRC

*** Providers
    Providers database stores all the configurations a provider may need, which is encoded in [[*Provider description][Provider description]] section.

**** Interface
    #+Name: providers-db-interface
    #+BEGIN_SRC go
      type providersDb interface {
          addProvider(providerDescription) err
          upgradeProvider(from providerDescription, to providerDescription) err
          listProvider() []providerDescription
          deleteProvider(providerUuid) err
      }
    #+END_SRC

** Dependent services
*** Tasks
    Tasks in Papiea's sense is not a process tracking mechanism. In a normal system, a process is started and it is
    assigned to a task which reflects the status of the running process, whether it succeeds or fails, return values or
    error messages etc.

    Papiea does not start a particular thread or process to converge a =Diff=. It may be converge by user interaction
    (such as changing the real underlying resource) or by invoking a provider's function. Such a function may succeed or
    fail and re-run again which may later succeed.

    A task is thus defined as a mechanism to track the progress of change towards a *particular* spec version. To get a
    clear understanding of the logic underlying this please see [[*Tasks][Tasks]] section below.

**** Interface
     #+Name: task-interface
     #+BEGIN_SRC go
       type task interface {
           newTask(metadata) task
       }
     #+END_SRC
    
** Papiea Engine
*** Initialize
    When Papiea loads up, it needs to initialize its database connections, load the providers, generate entity
    validators and expose CRUD and [[*Procedures][Procedural]] APIs.
   
**** Interface    
    #+Name: initialize-papiea
    #+BEGIN_SRC go
      type papiea struct {
          api rest.api
          statusDb
          specDb
          providersDb
      }

      type papieaInit interface {
          initialize() papiea, err
      }
    #+END_SRC

**** Pseudocode
     #+Name: initialize-papiea-pc
     #+BEGIN_SRC go
       // Initialize papiea engine.
       func (papiea papiea) initialize() papiea, err {
           // Load databases, initialize db connections.
           papiea.statusDb
           papiea.specDb 
           papiea.providersDb

           // Sets up the rest api engine.
           papiea.api = new rest.api()

           // Start admin facing apis.
           papiea.adminFacingApis()

           // Start providers facing apis.
           papiea.providerFacingApi()

           // Start user facing apis.
           papiea.userFacingApi()
       }
     #+END_SRC
*** Exporting APIs
    Papiea provides three tiers of APIs: Admin, Provider and User facing.

    The struct that we need for the api will maintain an embedded =papiea= struct, and will add a
    =prefix=. Prefix is the http prefix for papiea api server, such as "/papiea/api/v1".

    #+Name: papiea-api-struct
    #+BEGIN_SRC go
      type papieaApiContext struct {
          *papiea
          prefix string
      }
    #+END_SRC
    
    Here is the interface for registring these apis:

    #+Name: exporting-apis
    #+BEGIN_SRC go
      type papieaApis interface {
          adminFacingApis() err
          providersFacingApi() err
          userFacingApi() err
      }
    #+END_SRC
    
    Next sections go into greater details into each of the apis.
**** Admin facing APIs
     The admin apis exposed by Papiea are used to manage providers: registrating, upgrading, deleting etc.
***** Pseudocode     
      #+Name: admin-api-pc
      #+BEGIN_SRC go
        func (papieaApis papieaApiContext) adminFacingApis() err {
            papieaApis.api.post(papieaApis.prefix+"/providers", func(req, res) procedureSignature{
                registerOrUpgradeProvider(req.providerDescription)
            })
        }
      #+END_SRC
     
**** Provider facing APIs
     Provider facing APIs define the interactions between a provider and the
     intent-engine.  They let the provider register [[*SFS - Status Fields Signature][Status Fields Signature]]
     handlers for intentful apis, and handlers for procedural apis which will be exposed to
     the user.

     Three apis are exposed:
     - =POST "/on"= - recieves an [[*SFS - Status Fields Signature][SF Signature]] and a callback url from the client. Registers the
       callback url to a component that listen on status changes and calls the callback url when a
       matching status change has taken place
     - =POST "/procedure"= - receives a [[*Procedures Signatures][Procedures Signatures]] and a callback url from the
       client. The signature is then used to expose a user facing api. When the user uses this api
       endpoint, the callback will get called
     - =POST "/status"= - sends a voluntary status update regarding an entity. Recieves a context
       which identifies the context in which this was called, the metadata of entity and its new
       status. This functionality is only exposed to the providers, since they are the only view
       Papiea has of the real world. 

     #+Name: provider-api-pc
     #+BEGIN_SRC go
       func (papieaApis papieaApiContext) providerFacingApi() err {
           // Registering Provider Facing APIs.
           api = papieaApis.api
           papieaPrefix = papieaApis.prefix
	
           api.post(papieaPrefix+"/on", func(req, res) {
               // Callback url is being generated by the papiea provider library and passed on the request.
               papieaApis.registerIntentfulCallback(req.signature, req.callbackUrl)
           })

           api.post(papieaPrefix+"/procedure", func(req, res) {
               // Callback url is being generated by the papiea provider library and passed on the request.
               papiea_apis.registerProceduralCallback(req.signature, req.callbackUrl)
           })

           // Status update is only exposed to providers. Users can't update status.
           api.post(papiea+"/status", func(req, res) {
               res.status(statusDb.updateStatus(req.uuid, req.status) ? 200 : 400)
               return res;
           })
       }


     #+END_SRC
**** User facing APIs
     
     #+Name: user-api-pc
     #+BEGIN_SRC go
       func (papiea papiea) userFacingApis() err {
           registeredProviders = papiea.providersDb.listProviders()

           for _, provider := range registeredProviders {
               for _, kind := range provider.kinds{
			
               }
           }
       }
     #+END_SRC
*** Change Spec
*** Update Status
*** SFS - Status Fields Signature
    When a spec change is submitted and successfully CAS'ed in, it is evaluated against the current
    status. The difference between this spec change and current status yields a Diff which is then
    evaluated using =Status Fields Signatures=. An SFS describes what changes in status needs to
    happen in order for the Diff to converge.

    This is a crucial element of the intent engine formalism, since it describes a way for the
    engine to "infer" which procedural actions are to be taken to complete an intentful
    specification.

    Here are a few examples of the proposed SFS syntax:
    1. =hosts.+{metadata.uuid}= - Matches when a new host entity (identified by =metadata.uuid=) has
       been added to the system. Typically this will the signature of a "create entity"
       function. 

    2. =hosts.-{metadata.uuid}= - Similar to the previous example, but this time the entity has been removed.
       
    3. =hosts.{metadata.uuid}.name= - Matches when an existing host is asking to rename. See the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

         new spec change: {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 4}
                           spec     {name "new name"                    << DIFF
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       In this example, after successfully CASing the new spec, the entity would look like this:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 4}               << Updated
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "new name"               << DIFF
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

       #+END_EXAMPLE

       We can see that the difference for the a particular host entity (as identified by the
       =metadata.uuid= value) is only in the =name= field. Thus, we want to find a function that
       knows how to transform the =name= status field. The engine will invoke the function that can
       resolve this diff.

    4. =hosts.{metadata.uuid}.networks.+{mac}= a handler that will get triggered when a new network
       is added to a vector found for key "networks", where the new network is identified by a field
       called "mac". Lets see this in the example, considering the =current host entity= as before:
       #+BEGIN_EXAMPLE
         new spec change: {metadata {uuid "1234"
                                     kind "host"
                                     specVersion 4}
                           spec     {name "a"
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}
                                               {mac "2.2.2.2.2"     << DIFF
                                                cidr "10.1.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       And we can see that once this new spec change will be CAS'ed in, there will be a diff only in
       the =network= key, and a new item (identifiable by =mac=) will be added. We need to invoke a
       function that knows how to add new networks to existing hosts.

    5. =hosts.{metadata.uuid}.networks.{mac}.cidr= Similar to the previous one, however, in here we
       are listening on a change of the =cidr= field inside an already existing network identifiable
       by =mac=. Now a function that changes cidr values for existing networks in existing hosts
       whould be invoked.
       
    6. =hosts.{metadata.uuid}.field_a, hosts.{metadata.uuid}.field_b= this is an example of a
       compound signature, which is matched when a single spec change has caused a difference in
       both =field_a= and =field_b= of a particular host, identified by =metadata.uuid=
       - We could revise the syntax to be something like =hosts.{metadata.uuid}.[field_a, field_b]= instead

    7. =hosts.{metadata.uuid}.field_a, hosts.{metadata.uuid}.inner.{id}.field_b= this is another
       example of a more complex signature, where a single spec change causes a difference in both
       =field_a= and =field_b= which is a compound object that lies inside a vector =inner= which is
       identified by =id=. Lets consider the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}
                                spec     {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}}

         new spec change: {metadata {uuid "1234"
                                          kind "host"
                                          spec_version 4}
                            spec     {field_a "another val 1"               << DIFF
                                      inner   [{id 1
                                                field_b "another val 2"}]}} << DIFF

       #+END_EXAMPLE

       In this example, the SFS would match the spec change if it gets CAS'ed in properly. This
       syntax could also be revised to something like =hosts.{metadata.uuid}.[field_a, inner.{id}.field_b]=
       

**** Formal syntax of SFS
     The following is a formal syntax describing SFS:

     #+BEGIN_EXAMPLE
      S                = (Single-diff ',')* Single-diff
      Single-diff      = Same-path Terminal
      Terminal         = Different-field | Added-by-field | Removed-by-field
      Same-path        = ((Key '.') | Id-into-vector)+
      Id-into-vector   = '{' (Key '.')* Key '}' '.'
      Key              = #'[a-zA-Z_]+'
      Added-by-field   = '+' Id-field
      Removed-by-field = '-' Id-field
      Id-field         = '{' (Key '.')* Key '}'
      Different-field  = Key
    #+END_EXAMPLE
    
**** SFS struct
    #+Name: sfs-signature
    #+BEGIN_SRC go
      type sfsSignature struct {
          signature string
          parsedSignatureAst ...
      }
    #+END_SRC
*** Procedures Signatures
    Procedures are functions that providers can expose directly to an entity. These functions are
    not intentful by design, and usually cannot be expressed in terms of a spec change.

    For example, consider asking a host to reboot. The =Power= status of a host can either be =On=
    or =Off=. However, a reboot is not a state of a machine, its a transition of the power state,
    and thus cannot be expressed in terms of a desired state. It is said to be a =Procedure= that is
    exposed on the host kind.

    Similarly to SFS, procedures are also registring based on a signature, lets see an example:
    
    - =hosts/{metadata.uuid}/reboot= - This signature refers to a =host= kind, will look a particular
      host up by matching the given uuid to the =metadata.uuid= field of the host, and expose a
      function called =reboot=. Seeing this signature will cause the engine to add a the following new api end point for the
      host kind:
      #+BEGIN_EXAMPLE
      POST "/hosts/{uuid}/reboot" 
      #+END_EXAMPLE
  
      Where ={uuid}= value will be matched against the host's =metadata.uuid=. Once a POST request for this
      route has been received by the user, the request will be forwarded to the callback url provided at registration time.
    
**** Procedure Signature struct
     #+Name: procedure-signature
     #+BEGIN_SRC go
       type procedureSignature struct {
           signature string
           parsedSignatureAst ...
       }
     #+END_SRC
*** Understanding Deltas
**** Matching SFSs to Deltas
**** Determining Order
*** Provider
    This section describes provider handling on Papiea's side. For the provider itself, please see [[*Provider Library][Provider Library]].
    
    As described in [[*Providers facing APIs][Providers facing APIs]] section, providers interact with the intetful engine by
    registring callbacks for two styles of actions:
    - Intentful actions - which are executed by analyzing their [[*SFS - Status Fields Signature][Status Fields Signature]]
    - Procedural actions - which are executed by a user interaction

    The following interface defines the registration mechanism for both kinds of actions:

    #+Name: provider-handler-interface
    #+BEGIN_SRC go
      type provider_callbacks interface {
          registerIntentfulCallback(sig sfsSignature, callbackUrl string) err
          registerProceduralCallback(sig procedureSignature, callbackUrl string) err
      }
    #+END_SRC

    The following pseudocode describes how these may be implemented:

    #+Name: provider-handler-pc
    #+BEGIN_SRC go
      func (api_ctx papieaApiContext) registerIntentfulCallback(sig sfsSignature, callbackUrl string) err {
          deltaAnalyzer.register(sig, callbackUrl)
      }

      func (api_ctx papiea_api_ctx) registerProceduralCallback(sig procedureSignature, callbackUrl string) err {
          procedures.register(sig, callbackUrl)
      }
    #+END_SRC
*** RBAC
*** Scalability and Reliability
**** Leader election
**** Fault tolerance
***** Dead Papiea Instance
***** Dead Provider
*** Auditing
** Tasks
*** Tracking change
*** Finished
** Provider Library
*** Define Entity Model
**** YAML
**** CRUD
*** Initialize
*** Callback Mechanism
*** Running Effect Validator
*** Status Changes Handlers
**** Registring
**** Running using context
*** Procedures
**** Registring
**** Running using context
*** Example Provider

* Full files
** /src/papiea/engine/core.go
   #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/core.go :exports code :mkdirp yes
   // All our structs and interfaces:
   
   // Untyped json for now. We should probably use some better library for that:
   <<untyped-json-type>>

   // Spec, status and metadata:
   <<spec-struct>>
   <<status-struct>>
   <<metadata-struct>>
   
   // Kind and providers:
   <<kind-struct>>
   <<provider-desc-struct>>

   // Define our database interfaces:
   <<stataus-db-interface>>
   <<spec-db-interface>>
   <<providers-db-interface>>
   
   // Services interfaces:
   <<task-interface>>

   // Provider APIs signatures.
   // Status Fields Signatures:
   <<sfs-signature>>

   // Procedure Signatures:
   <<procedure-signature>>

   // Provider handlers:
   <<provider-handler-interface>>

   // Papiea:
   <<initialize-papiea>>
   <<papiea_api_ctx>>
   <<papiea_apis>>
   
   #+END_SRC
** /src/papiea/engine/server.go
  #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/server.go :exports code :mkdirp yes
    #import stuff

    // Initialize Papiea.
    <<initialize-papiea-pc>>

    // Admin Facing APIs:
    <<admin-api-pc>>
    
    // Provider Facing APIS:
    <<provider-api-pc>>
    
    // User Facing APIs:
    <<user-api-pc>>
  #+END_SRC
  
** /src/papiea/engine/provider.go 
   #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/provider.go :exports code :mkdirp yes
   // Provider handler registration:
   <<provider-handler-pc>>
   #+END_SRC

* Last notes
  - I followed [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][this tutorial]] for generating the source files through this org-mode.
