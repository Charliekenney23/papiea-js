#+Title: Papiea Design
#+SETUPFILE: https://raw.githubusercontent.com/fniessen/org-html-themes/master/setup/theme-readtheorg.setup
#+Options: H:5

#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+HTML_HEAD: <style>#content{max-width:70%;} </style>

Papiea is aimed to be a reference implementation to a formal general purpose intent engine. 

* Definitions
  - _Spec_ - a map containing the desired state of a particular entity
  - _Status_ - a map containing the current statue of a particular entity. Always a superset of Spec
  - _Metadata_ - Information of the identity of the entity. Must contain at least =uuid=, =kind= and =spec_version=
  - _Spec version_ - an integer representing the version of the current spec. Updates to spec will =CAS= on this field
  - _Entity_ - The tuple =[Metadata, Spec, Status]=
  - _Kind_ - The "type" of the entity
  - _Diff_ - A difference between the current Status and the most recent desired Spec
  - _Providers_ - Pluggable handlers that can transform an entity from its current state to its desired state
  - _Tasks_ - a mechanism for following the progress of resolving Diffs
* Data Structures
** Spec
   Status and Spec are both unstructured, and may change at runtime (by changing providers). Go is a little afraid of
   unstructured types, so we have to be very gentle. Here is an example of how this could be achieved.
   
   First, lets declare an untyped json type:

   #+Name: untyped-json-type
   #+BEGIN_SRC go
   type untyped_json map[string]interface{}
   #+END_SRC

   Now, spec is simply an entyped_json
   #+Name: spec-struct
   #+BEGIN_SRC go
   type spec untyped_json
   #+END_SRC
** Status
   For now its strictly untyped, but there may be a better way to denote the fact that status is a super-set of spec

   #+Name: status-struct
   #+BEGIN_SRC go
   type status untyped_json
   #+END_SRC

** Metadata
   Metadata has a bit more structured then spec and status, it must have at least the following items:
   - =uuid= - a unique id representing the identity of this entity
   - =kind= - the "type" of this entity
   - =spec_version= - the most up-to-date revision of the spec associated with this entity
   #+Name: metadata-struct
   #+BEGIN_SRC go
     type metadata struct {
         uuid uuid
         kind string
         spec_version int
     }
   #+END_SRC
** Kind
   A Kind of an entity is the entity's type. It denotes the valid fields for spec and status for an instance of this kind.

   #+Name: kind-struct
   #+BEGIN_SRC go
     type kind struct {
         name string
         entity_structure untyped_json
     }
   #+END_SRC
** Provider description
   A Provider is a plugglable set of handlers, which is responsible for converging a certain entity kind. Its handlers
   are responsible to move the entity from a current status to an intended spec.
   #+Name: provider-desc-struct
   #+BEGIN_SRC go
     type provider_description struct {
         uuid uuid
         version int
         uri string
         kinds []kind
     }
   #+END_SRC

   It has a unique identifier and a version, as well as a uri that is a logical name that will be used to access an
   instance of the provider (since there may be multiple instances with a load-balancer). For example, a uri could be:
   =https://nunet.nutanix.com/hosts=. A provider may support multiple kinds but we believe it is best practice to have
   one provider per kind.

* Modules
** Databases
   #+BEGIN_note
   *Multitenancy*: All databases are aware of tenants. It may be implemented as a column or attribute of a table or
   document, or as a different database with a different connect uri.
   #+END_note
   
*** Status
    Status database will be a mapping from a metadata (namely, =uuid= and =kind=) to a status json document. 

    It may be implemented using a very fast in-memory database, since it may require frequent access depending on an
    entity's kind requirement. It is not required to have this database persisted to disk, since its content can always
    be reaquired by the providers, by asking all the providers to list all the real statuses of all objects known to
    them.

    Each provider for a kind will supply its entity's structure in its YAML.
    
**** Interface
    #+Name: status-db-interface
    #+BEGIN_SRC go
      type status_db interface {
          update_status(metadata, status) err
          get_status(metadata) status, err
          delete_status(metadata) err
          cleanup() err
      }
    #+END_SRC

*** Spec
    Unlike status which can always be fetched from the providers, spec is a record of the user's intent and must be
    persisted to disk. It must also be scalable and highly available. It must have a clear notion of CAS
    (compare-and-set/swap) in order to atomically update spec values.

**** Interface
    #+Name: spec-db-interface
    #+BEGIN_SRC go
      type spec_db interface {
          cas_spec_change(metadata, status) task, err
          get_latest_spec(metadata) metadata, spec, err
          cleanup() err
      }
    #+END_SRC

*** Providers
    Providers database stores all the configurations a provider may need, which is encoded in [[*Provider description][Provider description]] section.

**** Interface
    #+Name: providers-db-interface
    #+BEGIN_SRC go
      type providers_db interface {
          add_provider(provider_description) err
          upgrade_provider(from provider_description, to provider_description) err
          list_providers() []provider_description
          delete_provider(provider_uuid) err
      }
    #+END_SRC

** Dependent services
*** Tasks
    Tasks in Papiea's sense is not a process tracking mechanism. In a normal system, a process is started and it is
    assigned to a task which reflects the status of the running process, whether it succeeds or fails, return values or
    error messages etc.

    Papiea does not start a particular thread or process to converge a =Diff=. It may be converge by user interaction
    (such as changing the real underlying resource) or by invoking a provider's function. Such a function may succeed or
    fail and re-run again which may later succeed.

    A task is thus defined as a mechanism to track the progress of change towards a *particular* spec version. To get a
    clear understanding of the logic underlying this please see [[*Tasks][Tasks]] section below.

**** Interface
     #+Name: task-interface
     #+BEGIN_SRC go
       type task interface {
           new_task(metadata) task
       }
     #+END_SRC
    
** Papiea Engine
*** Initialize
    When Papiea loads up, it needs to initialize its database connections, load the providers, generate entity
    validators and expose CRUD and [[*Procedures][Procedural]] APIs.
   
**** Interface    
    #+Name: initialize-papiea
    #+BEGIN_SRC go
      type papiea struct {
          api rest.api
          status_db
          spec_db
          providers_db
      }

      type papiea-init interface {
          initialize() papiea, err
      }
    #+END_SRC

**** Pseudocode
     #+Name: initialize-papiea-pc
     #+BEGIN_SRC go
       // Initialize papiea engine
       func (papiea papiea) initialize() papiea, err {
           // Load databases
           papiea.status_db // initialize db connection
           papiea.spec_db // initialize db connection
           papiea.providers_db // initialize db connection

           // Sets up the rest api engine
           papiea.api = new rest.api()

           // Start admin facing apis
           papiea.admin_facing_apis()

           // Start providers facing apis
           papiea.provider_facing_api()

           // Start user facing apis
           papiea.user_facing_api()
       }
     #+END_SRC
*** Exporting APIs
    Papiea provides three tiers of APIs: Admin, Provider and User facing. 

    Here is the interface for registring these apis:
    
    #+Name: exporting-apis
    #+BEGIN_SRC go
      type papiea_apis interface {
          admin_facing_apis() err
          providers_facing_api() err
          user_facing_api() err
      }
    #+END_SRC
    
    Next sections go into greater details into each of the apis.
**** Admin facing APIs
     The admin apis exposed by Papiea are used to manage providers: registrating, upgrading, deleting etc.
***** Pseudocode     
      #+Name: admin-api-pc
      #+BEGIN_SRC go
        func (papiea papiea) admin_facing_apis() err {
            papiea.api.post(papiea_prefix+"/providers", func(req, res) {
                register_or_upgrade_provider(req.provider_description)
            })
        }
      #+END_SRC
     
**** Providers facing APIs
     Provider facing defines the interactions between a provider and the
     intent-engine.  It lets the provider register [[*SFS - Status Fields Signature][Status Fields Signature]]
     handlers for intentful apis, and procedural apis which will be exposed to
     the user.

     Three apis are exposed:
     - =POST "/on/"= - gets an [[*SFS - Status Fields Signature][SF Signature]] and a callback url from the client, and registers it to a component that
       listen on status changes and calls the callback url when a matching status change has taken place
     - =POST "/procedure"= - 
     - =POST "/status"= -

     #+Name: provider-api-pc
     #+BEGIN_SRC go
       // Registering Provider Facing APIs 
       api.post(papiea_prefix+"/on", func(req, res) {
           // callback url is being generated by the papiea provider library and passed on the request
           register_provider_intentful_callback(req.signature, req.callback_url);
       });

       api.post(papiea_prefix+"/procedure", func(req, res) {
           // callback url is being generated by the papiea provider library and passed on the request
           register_provider_procedural_callback(req.signature, req.callback_url);
       });

       // Status update is only exposed to providers. Users can't update status
       api.post(papiea+"/status", func(req, res) {
           res.status(update_status_in_db(req.uuid, req.status) ? 200 : 400);
           return res;
       })

       func register_provider_intentful_callback(signature, callback_url) {
       }

       
     #+END_SRC
**** User facing APIs
     
     #+Name: user-api-pc
     #+BEGIN_SRC go
       func (papiea papiea) user_facing_apis() err {
           registered_providers = papiea.providers_db.list_providers()

           for _, provider := range registered_providers {
               for _, kind := range provider.kinds{
			
               }
           }
       }
     #+END_SRC
*** Change Spec
*** Update Status
*** SFS - Status Fields Signature
*** Understanding Deltas
**** Matching SFSs to Deltas
**** Determining Order
*** Provider Invocation
*** RBAC
*** Scalability and Reliability
**** Leader election
**** Fault tolerance
***** Dead Papiea Instance
***** Dead Provider
*** Auditing
** Tasks
*** Tracking change
*** Finished
** Provider Library
*** Define Entity Model
**** YAML
**** CRUD
*** Initialize
*** Callback Mechanism
*** Running Effect Validator
*** Status Changes Handlers
**** Registring
**** Running using context
*** Procedures
**** Registring
**** Running using context
*** Example Provider

* Full files
** /src/papiea/engine/core.go
   #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/core.go :exports code :mkdirp yes
   // all our structs and interfaces
   
   // Define our structs and types

   // Untyped json for now. We should probably use some better library for that
   <<untyped-json-type>>

   // Spec, status and metadata
   <<spec-struct>>
   <<status-struct>>
   <<metadata-struct>>
   
   // Kind and providers
   <<kind-struct>>
   <<provider-desc-struct>>

   // Define our database interfaces
   <<stataus-db-interface>>
   <<spec-db-interface>>
   <<providers-db-interface>>
   
   // Services interfaces
   <<task-interface>>

   // Papiea
   <<initialize-papiea>>
   #+END_SRC
** /src/papiea/engine/server.go
  #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/server.go :exports code :mkdirp yes
    #import stuff

    // Initialize Papiea
    <<initialize-papiea-pc>>
  #+END_SRC
   
* Last notes
  - I followed [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][this tutorial]] for generating the source files through this org-mode.
