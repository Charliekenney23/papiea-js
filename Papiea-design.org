#+Title: Papiea Design
#+SETUPFILE: https://raw.githubusercontent.com/fniessen/org-html-themes/master/setup/theme-readtheorg.setup
#+Options: H:5

#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+HTML_HEAD: <style>#content{max-width:70%;} </style>

Papiea is aimed to be a reference implementation of a formal general purpose intent engine. 

* Definitions
  - _Spec_ - a map containing the desired state of a particular entity
  - _Status_ - a map containing the current statue of a particular entity. Always a superset of Spec
  - _Metadata_ - Information of the identity of the entity. Must contain at least =uuid=, =kind= and =specVersion=
  - _Spec version_ - an integer representing the version of the current spec. Updates to spec will
    use this field to ensure that the change will be atomic
  - _Entity_ - The tuple =[Metadata, Spec, Status]=
  - _Kind_ - The "type" of the entity
  - _Diff_ - A difference between the current Status and the most recent desired Spec
  - _Providers_ - Pluggable handlers that can transform an entity from its current state to its desired state
  - _Tasks_ - a mechanism for following the progress of resolving Diffs
* Basic Interfaces
  The main concept behind the intentful approach is the ability to know what is the desired state of
  our system and what is the actual current state. Once we have this knowledge, many different kinds
  of engines could be built that would attempt to resolve to tension formed when the intended state,
  termed the =Spec=, is different from the current state of the system, termed the =Status=.

  In Papiea, we use both =Spec= and =Status= to have a complete view of the state of a given entity
  identity, marked by the =Metadata=. The following interfaces capture these most basic concepts.

** Metadata
   Metadata has a structured portion which contains fields that defines the identity of a particular
   entity. The fields that identify the entity are:
   - =uuid= - a unique id representing the identity of this entity
   - =kind= - the "type" of this entity
   - =spec_version= - the most up-to-date revision of the spec associated with this entity

   Other fields are also important:
   - =created_at= - logs when this entity was created
   - =delete_at= - annouces if and when will this entity be deleted. If this field is set the entity
     will be deleted by a [[*Cleanup process][Cleanup process]].
    
   #+Name: metadata-struct
   #+BEGIN_SRC typescript
     interface Metadata {
         // Identity fields
         uuid: uuid4;
         kind: string;
         specVersion: number;

         // Additional fields
         created_at: timestamp;
         delete_at: timestamp;
     }
   #+END_SRC
  
** Spec
   The =Spec=, which is the desired state, is simply a json object, or an unstructured map. It can
   and should get a structure when used specifically by any particular entity [[*Kind][Kind]]. However, at the
   engine level, a spec is an unstructured map that can be compared to the mirroring =Status= map to
   find any differences. The structure definintion may change by the provider which defines it, say
   by upgrading to a newer version (See TODO:).

   #+Name: spec-struct
   #+BEGIN_SRC typescript
   type Spec = any;
   #+END_SRC

** Status
   The =Status=, which is a representation of the true current state of the entity, is also simply a
   json. Its content and structure is a superset of [[*Spec][Spec]], meaning that every field in =Spec= will
   also appear in =Status=, but may contain any extra fields as desired by the provider.

   I am just learning typescript, so still not sure how to express that =Status= is an extension of
   =Spec=, but it should be explicit.

   #+Name: status-struct
   #+BEGIN_SRC typescript
   type Status = any;
   #+END_SRC

** Entity
   An Entity is simply the tuple =(Metadata, Spec, Status)=. It usually denotes a snapshot in time of a particular entity.

   #+Name: entity-struct
   #+BEGIN_SRC typescript
     interface Entity {
       metadata: Metadata;
       spec: Spec;
       status: Status
     }
   #+END_SRC

** Kind
   A Kind is the entity's metadata. It contains an entire description of what the entity is and what
   it may do. This information will be used to provideing full CRUD operation on the entity
   structure along with custom procedures and intentful handlers.

   #+Name: kind-struct
   #+BEGIN_SRC typescript
     // Intentful signature
     type sfs: string;

     type provider_callback_url: string;
     
     interface Kind {
         name: string;
         name_plural: string;

         //// Entity structure
         kind_structure: parsed_yaml;
         validator_fn: (entity:entity)=>boolean;
         semantic_validator_fn?: provider_callback_url; 

         //// Intentful behavior
         intentful_tasks: map<sfs, Intentful_Behavior>;

         // Every sfs lists the sfs's it has to execute before
         dependency_tree: map<sfs, sfs[]>;
         
         differ: Differ<Kind>;

         //// Procedural behavior
         procedures: map<string, Procedure>;
     }
   #+END_SRC
   
   A Kind metadata contains the following pieces:
   1. Identification and structure:
      1. a unique name along with its plural form, to generate idiomatic REST API. There may be a
         library function that create plural form, if so it should be used instead.

      2. The description of the data structre defined by this kind. The structure is defined using
         OpenAPI's model format (Swagger), which is parsed into a walkable tree.

      3. A Validator function is generated from this OpenAPI model specification. The purpose of the
         validator function is to ensure that the entity that was sent by the user is syntactically
         (structurally) correct.

      4. an optional semantic validator function is defined as a predicate exposed by the [[*Provider's SDK][Provider's
         SDK]]. It will be used to ensure that the content of the entity is correct.

   2. Intentful behavior
      1. A map from an intentful signature (see [[*SFS - Status Fields Signature][SFS - Status Fields Signature]]) to a structure
         representing the intentful behavior (see TODO:).

      2. Dependency tree between the different intentful behaviors.

      3. Using the two items above, a =Differ= is compiled. The Differ's task is to determine if
         there are any relevant differences between an entity's spec and status (relevant in this
         context means "a diff such that there exists at least one intentful behavior which can
         resolve it").

   3. Procedural behavior
      1. a map from the procedure name to a structure defining that procedure, its input argument
         and output result structures, execution strategy, etc. (see TODO:)
  
** Entity Reference
   Entities can point to other entities using a reference. A reference may onlu refers to the
   identity of an entity, and it is the intent engine that returns the entity's most recent spec and
   most current status.

   #+Name: entity-reference-struct
   #+BEGIN_SRC typescript
     interface entity_reference  {
         uuid: uuid4;
         kind: string;

         // This field is optional and is only used help the user identify
         // what this reference is pointing to. 
         name?: string;
     }
   #+END_SRC

** Provider description
   Papiea is extensible by the use of =Providers=.  A Provider defines entities by providing their
   structure, their procedures and intentful behaviors. Along with declaratively define the entity's
   structure, it also enables intentful behaviors by defining how differences between spec and
   status may be resolved. The Provider is pluggable at runtime, and should maintain no internal
   state, which should allow for simpler methods of scaling.

   #+Name: provider-desc-struct
   #+BEGIN_SRC typescript
     type Provider_Description struct {
         uuid: uuid4;
         version: Version;
         kinds: Kind[]
     }
   #+END_SRC

   A =Provider Description= contains:
   1. A unique identifier for that provider
   2. A version of that provider
   3. The list of Kinds supported by this provider

* Modules
** Databases
   #+BEGIN_note
   *Multitenancy*: All databases are aware of tenants. It may be implemented as a column or
   attribute of a table or document, or as a different database with a different connect uri.
   #+END_note
   
*** Status
    Status database will be a mapping from a metadata (namely, =uuid= and =kind=) to a status json document. 

    It may be implemented using a fast in-memory database, since it may require frequent rapid
    access depending on an entity's kind requirement. It is not required that this database be
    persisted to disk. Its content MUST always be re-acquirable by the providers, simply by asking
    all the providers to list up-to-date status of all objects known to them.

    Each provider for a kind will supply its entity's structure in its YAML.
    
**** Interface
    #+Name: status-db-interface
    #+BEGIN_SRC typescript
      interface Spec_DB {
          // Tries to update the spec. Succeeds only if the spec_version
          // field in metadata is currently equals to the one on record. The
          // implementation needs to CAS the spec_version to the increment
          // of itself, and return the new metadata with the new
          // spec_version and the new CASed in spec.
          update_spec(meta:metadata, spec:spec):[boolean, metadata, spec];

          // Get the spec of a particular entity from the db. Returns both
          // current metadata and the spec of that entity.
          get_spec(meta:metadata):[metadata, spec];

          // List all specs that have their fields match the ones given in
          // fields_map. E.g. we could look for all specs for `vm` kind that
          // have a certain ip:
          // list_specs({"metadata": {"kind": "vm"},
          //             "spec":     {"ip":   "10.0.0.10"}})
          //
          // We could come up with command such as greater-than etc at some
          // later point, or we could use a similar dsl to mongodb search
          // dsl.
          list_specs(fields_map: any): [metadata, spec][];
      }
    #+END_SRC

*** Spec
    Unlike status which can always be fetched from the providers, spec is a record of the user's
    intent and must be persistent. It must also be scalable and highly available. It must have a
    clear notion of atomicity (such as compare-and-set/swap) in order to atomically update spec
    values.

**** Interface
    #+Name: spec-db-interface
    #+BEGIN_SRC go
      interface Status_DB{
          // Update the status in the status db. As long as the input is
          // correct this always succeeds.
          update_status(meta:metadata, status:status):boolean;

          // Gets the status of a particular entity from the db. Returns
          // both current metadata and status of the entity.
          get_status(meta:metadata):[metadata, status];

          // List all status that have their fields match the ones given in
          // fields_map. E.g. we could look for all specs for `vm` kind that
          // have a certain ip:
          // list_specs({"metadata": {"kind": "vm"},
          //             "status":   {"ip":   "10.0.0.10"}})
          //
          // We could come up with command such as greater-than etc at some
          // later point, or we could use a similar dsl to mongodb search
          // dsl.
          list_specs(fields_map: any): [metadata, status][];
      }
    #+END_SRC

*** Providers
    Providers database stores all the configurations a provider has registered (encoded in [[*Provider description][Provider
    description]] section). It is used by the engine to record which providers are registered. The
    engine uses this indirectly to initialize all user-facing APIs. This seperation makes it easy to
    scale the engine to many instances.

**** Interface
    #+Name: providers-db-interface
    #+BEGIN_SRC typescript
      interface Providers_DB {

          // Register a new provider with the intent engine
          register_provider(provider: Provider_Description):void;

          //Upgrade a provider
          upgrade_provider(from_provider: uuid4, to: providerDescription): Task;

          // List all registered providers
          listProviders(): providerDescription[]

          // Removes and de-registers a provider from the intent engine
          deleteProvider(provider: uuid4): boolean;
      }
    #+END_SRC

** Dependent services
*** Tasks
    Papiea defines a task to be a mechanism that tracks the progress of change towards a
    *particular* spec version. It does not matter how the change took place: through a provider,
    manually or by an error. A task will listen on the relevant status changes and mark off the
    different fields as they get resolved. To get a clearer understanding of the logic underlying
    this please see [[*Intentful Tasks][Intentful Tasks]] section below.

    #+BEGIN_note
    Unlike the traditional definition of a task as a handle to a running process, Papiea does not
    start a particular thread or process to that works on a =Diff=. Instead the task simply listens
    the relevant changes in the entity and tracks its progress. 
    #+END_note
    
**** Interface
     #+Name: task-interface
     #+BEGIN_SRC typescript
       interface Task {
           wait():any;
       } 

       function new_task (): Task;
       function new_intentful_task (ent: Entity_reference, spec: spec): Task;
     #+END_SRC
    
     A Task allows you to wait for it to finish.

** Papiea Engine
*** Initialize
    When Papiea loads up, it needs to initialize its database connections, load the providers,
    generate entity validators and expose CRUD and [[*Procedures][Procedural]] APIs.
   
**** Interface
    #+Name: initialize-papiea
    #+BEGIN_SRC typescript
      interface Papiea {

          // api is the mechanism which adds REST endpoints to Papiea.
          api: route;
          prefix: string;

          statuses: Status_DB;
          specs: Spec_DB;
          providers: Providers_DB;
      } 
      
      function initialize_papiea(): Papiea;
    #+END_SRC

**** Pseudocode
     #+Name: initialize-papiea-pc
     #+BEGIN_SRC typescript
       // Initialize papiea engine.
       function initialize_papiea(): Papiea {
           // Load databases, initialize db connections.
           papiea.statusDb
           papiea.specDb 
           papiea.providersDb

           // Sets up the rest api engine.
           papiea.api = new rest.api()

           // Start admin facing apis.
           papiea.create_admin_facing_API();

           // Start providers facing apis.
           papiea.create_providers_facing_API();

           // Start user facing apis.
           papiea.create_user_facing_API();
       }
     #+END_SRC
*** Exporting APIs
    Papiea provides three tiers of APIs: Admin, Provider and User facing.

    #+Name: exporting-apis
    #+BEGIN_SRC go
      interface papiea_APIs {
          create_admin_facing_API(papiea:Papiea):void
          create_provider_facing_API(papiea:Papiea):void
          create_user_facing_API(papiea:Papiea):void
      }
    #+END_SRC
    
    Next sections go into greater details into each of the apis.
**** Admin facing APIs
     The admin apis exposed by Papiea are used to manage providers: registrating, upgrading, deleting etc.
***** Pseudocode
      #+Name: admin-api-pc
      #+BEGIN_SRC typescript
        function create_admin_facing_API(papiea:Papiea) {
    
            // An example for registring a new provider from a provider description
            papiea.api.POST(papiea.api.prefix+ "/providers", function(req, res) {
                registerOrUpgradeProvider(req.providerDescription);
            });

            // ...
        }
      #+END_SRC
     
**** Provider facing APIs
     Provider has two sets of APIs:
***** Provider's SDK    
      This is actually an SDK rather than an API. The distinction is that this is used by the
      providers developers to define and expose behaviors and APIs to the end user.

      This SDK will be availagble in a few languages: Javascript and golang are planned first, but
      more should come.

      The core is the =Provider= abstraction:
      #+BEGIN_SRC typescript
        // Api for the provider-sdk
        enum ProviderPower {On, Off, Suspended};

        interface Provider {
            new_kind(entity_yaml:string):Kind;
            version(major:number, minor:number, build: number, extra: string):void;
            power(state: ProviderPower): ProviderPower;
        }
      #+END_SRC

      This allows us to register a new kind (see below), establish a version and change the "Power
      state" of this provider instance. 

      A Kind is added when the user supplies a valid description for the entity handled by this
      kind. Once the kind's entity description is validated, an object of type =Kind= is returned on
      which we can do the following things:

      #+BEGIN_SRC typescript
        enum ProceduralExecStrategy {HaltIntentful};

        interface Kind {

            // Adds an intentful handler. Dispatched based on the signautre passed
            on(signature: string, name: string, rbac: any, handler: (ctx:IntentfulCtx, entity:any)=>void):IntentfulHandler;

            // Convenient functions for constructing/destructing an entity. Could be implemented in terms of "on above"
            on_new(name: string, rbac: any, handler: (ctx:IntentfulCtx, entity:any)=>void):void;
            on_del(name: string, rbac: any, handler: (ctx:IntentfulCtx, entity:any)=>void):void;

            // Adds a procedural behaviour to the entity
            procedure(name: string, rbac: any,
                      strategy: ProceduralExecStrategy,
                      input_desc: string,
                      output_desc: string,
                      handler: (ctx:ProceduralCtx, input:any)=>any):void;


            // Visualize all the intentful handlers and their priority
            visualize_intentful_handlers(filename:string):boolean;
        }
      #+END_SRC
      
      We can add an intentful behavior to any set of changes to the entity's fields, either spec (a
      user's intent) or a status with the =on= function.

      We could also register a procedure on that entity. The procedure should not change status is
      ways that may cause diffs, otherwise the intent engine will try to "resolve" the diff incured
      by the procedure. A procedure may state that during its execution, no intentful behavior
      should be handled. If that is the case, when the procedure finishes execution, the =Differ=
      will run on the entity to see if any deltas are needed to get resolved.

      When we have multiple intentful handlers, it may be desirable to be able to define a
      dependency tree between the different intentful handlers. Which should execute before which:
      
      #+BEGIN_SRC typescript
        interface IntentfulHandler {
            // Establishes a dependency tree between the various handlers
            before(...handlers: IntentfulHandler[]):void;
        }
      #+END_SRC

      In this snippet, =h1.before(h2, h3)= would mean that if the =Differ= discovered that both
      =h1=, =h2= and =h3= are possibilities of execution, the handler =h1= should execute first,
      then =h2= and =h3= have no specific ordering. In cases of no order, the handler with the most
      specific signature (i.e. longest) should run first, if both are equal one would be selected at
      random.

      During the execution of an intentful handler, the following functionality could be used:
      #+BEGIN_SRC typescript

        interface IntentfulCtx {
            update_status(metadata:any, status: any):boolean;
            update_progress(message:string, done_percent:number):boolean;
        }

        // For the time being these are equal. Later they may differ
        type ProceduralCtx=IntentfulCtx;
      #+END_SRC

      During the execution of a handler we may want to set up the status of the entity we are
      working on, or perhaps update the task with our progress (if we have one). 

      I would say that best practice is to have a single =get_status(entity_metadata)= function that
      constructs a full status map out of the real resource, and only call =update_status(metadata,
      get_status(metadata))=, as this will ensure that even in case of a crash the status we saved
      is the exact one that would any way be generated by looking at the real resource.

***** Provider to Papiea APIs
     Provider facing APIs define the interactions between a provider and the
     intent-engine.  They let the provider register [[*SFS - Status Fields Signature][Status Fields Signature]]
     handlers for intentful apis, and handlers for procedural apis which will be exposed to
     the user.

     Three apis are exposed:
     - =POST "/status"= - sends a voluntary status update regarding an entity. Recieves a context
       which identifies the context in which this was called, the metadata of entity and its new
       status. This functionality is only exposed to the providers, since they are the only view
       Papiea has of the real world. 
     - =POST "/progress= - sends a voluntary progress update for the task, should one exist. 

     #+Name: provider-api-pc
     #+BEGIN_SRC typescript
       function create_provider_facing_API(papiea: Papiea) {
           // Registering Provider Facing APIs.
           api = papieaApis.api
           papieaPrefix = papieaApis.prefix

           // Status update is only exposed to providers. Users can't update status.
           api.POST(papiea+"/status", function(req, res) {
               res.status(statusDb.updateStatus(req.uuid, req.status) ? 200 : 400)
               return res;
           })

           // 
           api.POST(papiea+"/progress", function(req, res) {
               //...
               return res;
           })
       }
     #+END_SRC
**** User facing APIs
     The user facing APIs will be generated from all the registered kinds of all registered
     providers. The following pseudo-code will be demosstrating how the CRUD may be implemented.

     #+Name: user-api-pc
     #+BEGIN_SRC typescript
       function create_user_facing_API(papiea: Papiea) {
           papiea.providers.listProviders.forEach((provider_desc)=>{
               provider_desc.kinds.forEach((kind)=>{

                   // define CRUD for entity:
                   // Create: 
                   papiea.api.POST(papiea.prefix + "/" + kind.name_plural, (req, res)=>{
                       if (!kind.validator_fn(req.spec)) {
                           res.status(400).send("Does not conform syntactically");
                           return;
                       }

                       if (kind.semantic_validator_fn && rest.post(kind.semantic_validator_fn, req.spec)!=200) {
                           res.status(400).send("Does not conform semantically");
                           return;
                       }

                       // create and return the task
                       let task = create_task(...);
                       return task; // magically return here.

                       // The followin code should run after the return, so
                       // maybe async, maybe some event loop etc.
                       if (!papiea.spec_db.update_spec(req.metadata, req.spec)) {
                           task.fail("could not cas task")
                       }

                       // invoke on_new

                   });

                   // Update: The core of our intentfullness
                   papiea.api.PUT(papiea.prefix + "/" + kind.name_plural + "/{uuid}", (req, res)=>{
                       if (!kind.validator_fn(req.spec)) {
                           res.status(400).send("Does not conform syntactically");
                           return;
                       }

                       if (kind.semantic_validator_fn && rest.post(kind.semantic_validator_fn, req.spec)!=200) {
                           res.status(400).send("Does not conform semantically");
                           return;
                       }

                       // create and return the task
                       let task = create_task(...);
                       return task; // magically return here.

                       // The followin code should run after the return, so
                       // maybe async, maybe some event loop etc.
                       if (!papiea.spec_db.update_spec(req.metadata, req.spec)) {
                           task.fail("could not cas task")
                       }

                       let status = papiea.status_db.get_status({kind: kind.name, uuid: kind.uuid});

                       // Get the next diff
                       let next_func = provider_desc.differ(req.spec, status);

                       // invoke it
                       rest.post(next_func);
                   });

                   // Read
                   papiea.api.GET(papiea.prefix + "/" + kind.name_plural + "/{uuid}", (req, res)=>{

                       // metadata is stored in spec as well
                       let spec   = papiea.spec_db.get_spec({kind: kind.name, uuid: kind.uuid});
                       let status = papiea.status_db.get_status({kind: kind.name, uuid: kind.uuid});

                       res.status(200).send(entity(spec, status));
                       return;
                   });
               });
           });
       };

     #+END_SRC
*** Change Spec
*** Update Status
*** SFS - Status Fields Signature                             :CONTINUE_HERE:
    When a spec change is submitted and successfully atomically swapped in, it is evaluated against
    the current status. The difference between this spec change and current status yields a Diff
    which is then evaluated using =Status Fields Signatures=. An SFS describes what changes in
    status needs to happen in order for the Diff to converge.

    This is a crucial element of the intent engine formalism, since it describes a way for the
    engine to "infer" which procedural actions are to be taken to complete an intentful
    specification.

    Here are a few examples of the proposed SFS syntax:
    1. =hosts.+{metadata.uuid}= - Matches when a new host entity (identified by =metadata.uuid=) has
       been added to the system. Typically this will the signature of a "create entity"
       function. 

    2. =hosts.-{metadata.uuid}= - Similar to the previous example, but this time the entity has been removed.
       
    3. =hosts.{metadata.uuid}.name= - Matches when an existing host is asking to rename. See the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

         new spec change: {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 4}
                           spec     {name "new name"                    << DIFF
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       In this example, after a successfully setting the new spec, the entity would look like this:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 4}               << Updated
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "new name"               << DIFF
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

       #+END_EXAMPLE

       We can see that the difference for the a particular host entity (as identified by the
       =metadata.uuid= value) is only in the =name= field. Thus, we want to find a function that
       knows how to transform the =name= status field. The engine will invoke the function that can
       resolve this diff.

    4. =hosts.{metadata.uuid}.networks.+{mac}= a handler that will get triggered when a new network
       is added to a vector found for key "networks", where the new network is identified by a field
       called "mac". Lets see this in the example, considering the =current host entity= as before:
       #+BEGIN_EXAMPLE
         new spec change: {metadata {uuid "1234"
                                     kind "host"
                                     specVersion 4}
                           spec     {name "a"
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}
                                               {mac "2.2.2.2.2"     << DIFF
                                                cidr "10.1.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       And we can see that once this new spec change will be atomically swapped in, there will be a
       diff only in the =network= key, and a new item (identifiable by =mac=) will be added. We need
       to invoke a function that knows how to add new networks to existing hosts.

    5. =hosts.{metadata.uuid}.networks.{mac}.cidr= Similar to the previous one, however, in here we
       are listening on a change of the =cidr= field inside an already existing network identifiable
       by =mac=. Now a function that changes cidr values for existing networks in existing hosts
       whould be invoked.
       
    6. =hosts.{metadata.uuid}.field_a, hosts.{metadata.uuid}.field_b= this is an example of a
       compound signature, which is matched when a single spec change has caused a difference in
       both =field_a= and =field_b= of a particular host, identified by =metadata.uuid=
       - We could revise the syntax to be something like =hosts.{metadata.uuid}.[field_a, field_b]= instead

    7. =hosts.{metadata.uuid}.field_a, hosts.{metadata.uuid}.inner.{id}.field_b= this is another
       example of a more complex signature, where a single spec change causes a difference in both
       =field_a= and =field_b= which is a compound object that lies inside a vector =inner= which is
       identified by =id=. Lets consider the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}
                                spec     {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}}

         new spec change: {metadata {uuid "1234"
                                          kind "host"
                                          spec_version 4}
                            spec     {field_a "another val 1"               << DIFF
                                      inner   [{id 1
                                                field_b "another val 2"}]}} << DIFF

       #+END_EXAMPLE

       In this example, the SFS would match the spec change if it gets atomically swapped in
       properly. This syntax could also be revised to something like
       =hosts.{metadata.uuid}.[field_a, inner.{id}.field_b]=
       

**** Formal syntax of SFS
     The following is a formal syntax describing SFS:

     #+BEGIN_EXAMPLE
      S                = (Single-diff ',')* Single-diff
      Single-diff      = Same-path Terminal
      Terminal         = Different-field | Added-by-field | Removed-by-field
      Same-path        = ((Key '.') | Id-into-vector)+
      Id-into-vector   = '{' (Key '.')* Key '}' '.'
      Key              = #'[a-zA-Z_]+'
      Added-by-field   = '+' Id-field
      Removed-by-field = '-' Id-field
      Id-field         = '{' (Key '.')* Key '}'
      Different-field  = Key
    #+END_EXAMPLE
    
**** SFS struct
    #+Name: sfs-signature
    #+BEGIN_SRC go
      type sfsSignature struct {
          signature string
          parsedSignatureAst ...
      }
    #+END_SRC
*** Procedures Signatures
    Procedures are functions that providers can expose directly to an entity. These functions are
    not intentful by design, and usually cannot be expressed in terms of a spec change.

    For example, consider asking a host to reboot. The =Power= status of a host can either be =On=
    or =Off=. However, a reboot is not a state of a machine, its a transition of the power state,
    and thus cannot be expressed in terms of a desired state. It is said to be a =Procedure= that is
    exposed on the host kind.

    Similarly to SFS, procedures are also registring based on a signature, lets see an example:
    
    - =hosts/{metadata.uuid}/reboot= - This signature refers to a =host= kind, will look a particular
      host up by matching the given uuid to the =metadata.uuid= field of the host, and expose a
      function called =reboot=. Seeing this signature will cause the engine to add a the following new api end point for the
      host kind:
      #+BEGIN_EXAMPLE
      POST "/hosts/{uuid}/reboot" 
      #+END_EXAMPLE
  
      Where ={uuid}= value will be matched against the host's =metadata.uuid=. Once a POST request for this
      route has been received by the user, the request will be forwarded to the callback url provided at registration time.
    
**** Procedure Signature struct
     #+Name: procedure-signature
     #+BEGIN_SRC go
       type procedureSignature struct {
           signature string
           parsedSignatureAst ...
       }
     #+END_SRC
*** Understanding Deltas
**** Matching SFSs to Deltas
**** Determining Order
*** Provider
    This section describes provider handling on Papiea's side. For the provider itself, please see [[*Provider Library][Provider Library]].
    
    As described in [[*Provider facing APIs][Provider facing APIs]] section, providers interact with the intetful engine by
    registring callbacks for two styles of actions:
    - Intentful actions - which are executed by analyzing their [[*SFS - Status Fields Signature][Status Fields Signature]]
    - Procedural actions - which are executed by a user interaction

    The following interface defines the registration mechanism for both kinds of actions:

    #+Name: provider-handler-interface
    #+BEGIN_SRC go
      type provider_callbacks interface {
          registerIntentfulCallback(sig sfsSignature, callbackUrl string) err
          registerProceduralCallback(sig procedureSignature, callbackUrl string) err
      }
    #+END_SRC

    The following pseudocode describes how these may be implemented:

    #+Name: provider-handler-pc
    #+BEGIN_SRC go
      func (api_ctx papieaApiContext) registerIntentfulCallback(sig sfsSignature, callbackUrl string) err {
          deltaAnalyzer.register(sig, callbackUrl)
      }

      func (api_ctx papiea_api_ctx) registerProceduralCallback(sig procedureSignature, callbackUrl string) err {
          procedures.register(sig, callbackUrl)
      }
    #+END_SRC
*** RBCA - test
*** Scalability and Reliability
**** Leader election
**** Fault tolerance
***** Dead Papiea Instance
***** Dead Provider
*** Cleanup process
    - automatic deletion?
*** Auditing
** Intentful Tasks
   Tasks are intentful in our intent engine. This means that a task defines an intent to "get
   notified when a certain change request has completed". 

   A new task is started in the context of providing a new spec change. Since a spec change is
   atomically swapped by the engine, a task for a particular spec change may fail simply for not
   being able to atomically perform the swap (such as CAS failures in certain atomicity
   models). Once a spec change has been properly and atomically swapped in, the task registers a
   status change listener using [[*SFS - Status Fields Signature][SFS - Status Fields Signature]]. It will listen on all the fields that
   the spec change has requested to change. On every field, the following actions can happen:
   1. The field will get updated to the value that the spec change was requesting
      - Once this happens, this field is marked as successfully being fulfilled, the context of the
        status change may be logged for later auditing and the SFS for this field is stopped
   2. The field will get updated to a value that is *other* than the spec change was requesting
      - If this happens, the task will look to see if the spec version of the entity has increased
        - If it has, this field will be marked as *outdated* and teh SFS for this field is
          stopped. A reference to the outdating spec change may be maintained for later auditing.
        - If it still has the same spec version as the task, the task will not get updated
   
   Using this scheme, the task is said to be complete if there are no more active SFS listeners. It
   may be completed in three ways:
   1. Completed Successfully - All fields were set to the spec value at some point after the spec
      change was issued
   2. Completed Partially - Some fields were set to the spec value, and some were not due to a newer
      spec version
   3. Failed - non of the fields was changed to the given spec values, and there is already a newer
      spec version
   
   As long as there are still active SFS listeners in the task, it will be *pending*. It can show
   progress in terms of how many fields are left of the total fields. The intent engine will have to
   query pending tasks periodically to see if work has to be restarted.
   
   - TODO: What if a before a spec version has made a change to modify
     a field's value, a new spec change arrived that reverted the
     field's value to its value before the first spec change? This
     will cause status to never be updated because there is no
     difference between spec and status, but there is a task still
     listening.. Need to think about this
   
   #+Name: task-pc
   #+BEGIN_SRC go
     func (papiea papiea) newTask(entity entityReference, spec spec) {
         // Get the status of the entity we are trying to change.
         status,err = papiea.statusDb.getStatus(entity)


         // Calculate the delta between the spec and the status. calc_delta
         // will take into consideration all registered SFS for the
         // entity's kind in order to know how to diff on vector
         // elements. See more details in calc_delta. Each delta found will
         // record the corresponding SFS that could is registered which
         // should be able to resolve the diff
         delta = calc_delta(spec, status)

         // we are the task
         task = this

         // Register all the relevant deltas we could listen on
         task.registerDelta(delta)

         for (field in delta) {
             // TBD: define on, define context
             fieldListener = papiea.on(field.sfs, func(context, updatedEntity entityReference, status status){
                 newValue = status.get(field.path)
                 specValue = spec.get(field.path)

                 if (newValue == specValue) {
                     // Update the task that this field in the delta is a success
                     task.updateFieldStatus(field, "Success")

                     // Stopping this listener
                     task.removeFieldListener(this)
                 }
                 else if (entity.metadata.specVersion == updatedEntity.metadata.specVersion) {
                     // We got a different value, but still on the same spec version, dont do anything yet
                     // Add to audit
                     // Perhaps note this in some TTL
                 }
                 else {
                     // We got a different value AND the spec version has increased (it can only increase)

                     // update the task that this field is outdated by a particular spec version
                     task.updateFieldStatus(field, "Outdated by " + updatedEntity.metadata.specVersion)

                     // Stopping this listener
                     task.removeFieldListener(this)
                 }

                 task.verifyCompletness()
             })

             task.addFieldListener(fieldListener)
         }
     }

     func (papiea papiea) verifyCompletness() {
         if (task.noMoreFieldListeners()) {
             if (task.specDidNotRegister()) {
                 task.setStatus("Spec did not manage to be atomically committed. Try again.")
             }
             else if (task.hasFailedFields()) {
                 task.setStatus("Partially Completed")
             } else {
                 task.setStatus("Completed Successfully")
             }
         }
     }
   #+END_SRC
** Provider Library
*** Define Entity Model
**** YAML
**** CRUD
*** Initialize
*** Callback Mechanism
*** Running Effect Validator
*** Status Changes Handlers
**** Registring
**** Running using context
*** Procedures
**** Registring
**** Running using context
*** Example Provider

* Full files
** /src-go/papiea/engine/core.go
   #+BEGIN_SRC go :noweb yes :tangle src-go/papiea/engine/core.go :exports code :mkdirp yes
   // All our structs and interfaces:
   
   // Untyped json for now. We should probably use some better library for that:
   <<untyped-json-type>>

   // Spec, status and metadata:
   <<spec-struct>>
   <<status-struct>>
   <<metadata-struct>>
   
   // Kind and providers:
   <<kind-struct>>
   <<provider-desc-struct>>

   // Define our database interfaces:
   <<stataus-db-interface>>
   <<spec-db-interface>>
   <<providers-db-interface>>
   
   // Services interfaces:
   <<task-interface>>

   // Provider APIs signatures.
   // Status Fields Signatures:
   <<sfs-signature>>

   // Procedure Signatures:
   <<procedure-signature>>

   // Provider handlers:
   <<provider-handler-interface>>

   // Papiea:
   <<initialize-papiea>>
   <<papiea_api_ctx>>
   <<papiea_apis>>
   
   #+END_SRC
** /src-go/papiea/engine/server.go
  #+BEGIN_SRC go :noweb yes :tangle src-go/papiea/engine/server.go :exports code :mkdirp yes
    #import stuff

    // Initialize Papiea.
    <<initialize-papiea-pc>>

    // Admin Facing APIs:
    <<admin-api-pc>>
    
    // Provider Facing APIS:
    <<provider-api-pc>>
    
    // User Facing APIs:
    <<user-api-pc>>
  #+END_SRC
  
** /src-go/papiea/engine/provider.go 
   #+BEGIN_SRC go :noweb yes :tangle src-go/papiea/engine/provider.go :exports code :mkdirp yes
   // Provider handler registration:
   <<provider-handler-pc>>
   #+END_SRC

** /src-go/papiea/engine/tasks.go
   #+BEGIN_SRC go :noweb yes :tangle src-go/papiea/engine/tasks.go :exports code :mkdirp yes
   // Provider handler registration:
   <<task-pc>>
   #+END_SRC


* Last notes
  - I followed [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][this tutorial]] for generating the source files through this org-mode.
