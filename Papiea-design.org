#+Title: Papiea Design
#+SETUPFILE: https://raw.githubusercontent.com/fniessen/org-html-themes/master/setup/theme-readtheorg.setup
#+Options: H:5

#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+HTML_HEAD: <style>#content{max-width:70%;} </style>

Papiea is aimed to be a reference implementation of a formal general purpose intent engine. 

* Definitions
  - _Spec_ - a map containing the desired state of a particular entity
  - _Status_ - a map containing the current statue of a particular entity. Always a superset of Spec
  - _Metadata_ - Information of the identity of the entity. Must contain at least =uuid=, =kind= and =specVersion=
  - _Spec version_ - an integer representing the version of the current spec. Updates to spec will
    use this field to ensure that the change will be atomic
  - _Entity_ - The tuple =[Metadata, Spec, Status]=
  - _Kind_ - The "type" of the entity
  - _Diff_ - A difference between the current Status and the most recent desired Spec
  - _Providers_ - Pluggable handlers that can transform an entity from its current state to its desired state
  - _Tasks_ - a mechanism for following the progress of resolving Diffs
* Data Structures
** Spec
   Status and Spec are both unstructured, and may change at runtime (by changing providers). Go is a little afraid of
   unstructured types, so we have to be very gentle. Here is an example of how this could be achieved.
   
   First, lets declare an untyped json type:

   #+Name: untyped-json-type
   #+BEGIN_SRC go
   type untypedJson map[string]interface{}
   #+END_SRC

   Now, spec is simply an entyped_json
   #+Name: spec-struct
   #+BEGIN_SRC go
   type spec untypedJson
   #+END_SRC
** Status
   For now its strictly untyped, but there may be a better way to denote the fact that status is a super-set of spec

   #+Name: status-struct
   #+BEGIN_SRC go
   type status untypedJson
   #+END_SRC

** Metadata
   Metadata has a bit more structured then spec and status. It contains fields that defines the
   identity of a particular entity. The fields that identify the entity are:
   - =uuid= - a unique id representing the identity of this entity
   - =kind= - the "type" of this entity
   - =specVersion= - the most up-to-date revision of the spec associated with this entity

   Other fields are also important:
   - =created_at= - logs when this entity was created
   - =delete_at= - annouces if and when will this entity be deleted. If this field is set the entity
     will be deleted by a [[*Cleanup process][Cleanup process]].
    
   #+Name: metadata-struct
   #+BEGIN_SRC go
     type metadata struct {
         // Identity fields
         uuid uuid
         kind string
         specVersion int

         // Additional fields
         created_at timestamp
         delete_at timestamp
     }
   #+END_SRC
   
** Kind
   A Kind of an entity is the entity's type. It denotes the valid fields for spec and status for an
   instance of this kind. In Papiea, the kind struct maintains metadata about this kind, such as the
   description of an entity of that kind (its spec and status). This will be provided by the
   provider through the Swagger YAML

   #+Name: kind-struct
   #+BEGIN_SRC go
     type kind struct {
         name string
         entityStructure untypedJson
     }
   #+END_SRC

** Entity Reference
   Entities can point to other entities, based on a reference. A reference only refers to the
   identity of an entity, and it is up to the intent engine to return the entity's most recent spec
   and most current status.

   #+Name: entity-reference-struct
   #+BEGIN_SRC go
     type entityReference struct {
         uuid uuid
         kind string

         // This field is optional and is only used help the user identify
         // what this reference is pointing to
         name string 
     }
   #+END_SRC

** Provider description
   A Provider is a plugglable set of handlers, which is responsible for converging a certain entity kind. Its handlers
   are responsible to move the entity from a current status to an intended spec.
   #+Name: provider-desc-struct
   #+BEGIN_SRC go
     type providerDescription struct {
         uuid uuid
         version int
         uri string
         kinds []kind
     }
   #+END_SRC

   It has a unique identifier and a version, as well as a uri that is a logical name that will be used to access an
   instance of the provider (since there may be multiple instances with a load-balancer). For example, a uri could be:
   =https://nunet.nutanix.com/hosts=. A provider may support multiple kinds but we believe it is best practice to have
   one provider per kind.

* Modules
** Databases
   #+BEGIN_note
   *Multitenancy*: All databases are aware of tenants. It may be implemented as a column or attribute of a table or
   document, or as a different database with a different connect uri.
   #+END_note
   
*** Status
    Status database will be a mapping from a metadata (namely, =uuid= and =kind=) to a status json document. 

    It may be implemented using a very fast in-memory database, since it may require frequent access depending on an
    entity's kind requirement. It is not required to have this database persisted to disk, since its content can always
    be reacquired by the providers, by asking all the providers to list all the real statuses of all objects known to
    them.

    Each provider for a kind will supply its entity's structure in its YAML.
    
**** Interface
    #+Name: status-db-interface
    #+BEGIN_SRC go
      type statusDb interface {
          updateStatus(entityReference, status) err
          getStatus(entityReference) status, err
          deleteStatus(entityReference) err
      }
    #+END_SRC

*** Spec
    Unlike status which can always be fetched from the providers, spec is a record of the user's
    intent and must be persisted to disk. It must also be scalable and highly available. It must
    have a clear notion of atomicity (such as compare-and-set/swap) in order to atomically update
    spec values.

**** Interface
    #+Name: spec-db-interface
    #+BEGIN_SRC go
      type specDb interface {
          // AtomicSpecChange guarantees that changing the spec will be done
          // atomically. It could be implemented in terms of locks or CAS
          AtomicSpecChange(entityReference, status) task, err
          getLatestSpec(entityReference) metadata, spec, err
      }
    #+END_SRC

*** Providers
    Providers database stores all the configurations a provider may need, which is encoded in [[*Provider description][Provider description]] section.

**** Interface
    #+Name: providers-db-interface
    #+BEGIN_SRC go
      type providersDb interface {

          // Register a new provider with the intent engine
          addProvider(providerDescription) err

          // TODO: I am debating if to keep the =from= argument a
          // providerDescription which contains the uuid or to only get a
          // uuid.
          // Upgrade a provider
          upgradeProvider(from providerDescription, to providerDescription) err

          listProviders() []providerDescription

          // Removes and de-registers a provider from the intent engine
          deleteProvider(providerUuid) err
      }
    #+END_SRC

** Dependent services
*** Tasks
    Papiea defines a task to be a mechanism that tracks the progress of change towards a
    *particular* spec version. It does not matter how the change took place: through a provider,
    manually or by an error. A task will listen on the relevant status changes and mark off the
    different fields as they get resolved. To get a clearer understanding of the logic underlying
    this please see [[*Intentful Tasks][Intentful Tasks]] section below.

    #+BEGIN_note
    Unlike the traditional definition of a task as a handle to a running process, Papiea does not
    start a particular thread or process to that works on a =Diff=. Instead the task simply listens
    the relevant changes in the entity and tracks its progress. 
    #+END_note
    
**** Interface
     #+Name: task-interface
     #+BEGIN_SRC go
       type task interface {
           newTask(entityReference, spec) task
           // TODO: More will be added
       }
     #+END_SRC
    
** Papiea Engine
*** Initialize
    When Papiea loads up, it needs to initialize its database connections, load the providers, generate entity
    validators and expose CRUD and [[*Procedures][Procedural]] APIs.
   
**** Interface    
    #+Name: initialize-papiea
    #+BEGIN_SRC go
      type papiea struct {
          api rest.api
          statusDb
          specDb
          providersDb
      }

      type papieaInit interface {
          initialize() papiea, err
      }
    #+END_SRC

**** Pseudocode
     #+Name: initialize-papiea-pc
     #+BEGIN_SRC go
       // Initialize papiea engine.
       func (papiea papiea) initialize() papiea, err {
           // Load databases, initialize db connections.
           papiea.statusDb
           papiea.specDb 
           papiea.providersDb

           // Sets up the rest api engine.
           papiea.api = new rest.api()

           // Start admin facing apis.
           papiea.adminFacingApis()

           // Start providers facing apis.
           papiea.providerFacingApi()

           // Start user facing apis.
           papiea.userFacingApi()
       }
     #+END_SRC
*** Exporting APIs
    Papiea provides three tiers of APIs: Admin, Provider and User facing.

    The struct that we need for the api will maintain an embedded =papiea= struct, and will add a
    =prefix=. Prefix is the http prefix for papiea api server, such as "/papiea/api/v1".

    #+Name: papiea-api-struct
    #+BEGIN_SRC go
      type papieaApiContext struct {
          *papiea
          prefix string
      }
    #+END_SRC
    
    Here is the interface for registring these apis:

    #+Name: exporting-apis
    #+BEGIN_SRC go
      type papieaApis interface {
          adminFacingApis() err
          providerFacingApi() err
          userFacingApi() err
      }
    #+END_SRC
    
    Next sections go into greater details into each of the apis.
**** Admin facing APIs
     The admin apis exposed by Papiea are used to manage providers: registrating, upgrading, deleting etc.
***** Pseudocode     
      #+Name: admin-api-pc
      #+BEGIN_SRC go
        func (papieaApis papieaApiContext) adminFacingApis() err {
            papieaApis.api.post(papieaApis.prefix+"/providers", func(req, res) procedureSignature{
                registerOrUpgradeProvider(req.providerDescription)
            })
        }
      #+END_SRC
     
**** Provider facing APIs
     Provider facing APIs define the interactions between a provider and the
     intent-engine.  They let the provider register [[*SFS - Status Fields Signature][Status Fields Signature]]
     handlers for intentful apis, and handlers for procedural apis which will be exposed to
     the user.

     Three apis are exposed:
     - =POST "/on"= - recieves an [[*SFS - Status Fields Signature][SF Signature]] and a callback url from the client. Registers the
       callback url to a component that listen on status changes and calls the callback url when a
       matching status change has taken place
     - =POST "/procedure"= - receives a [[*Procedures Signatures][Procedures Signatures]] and a callback url from the
       client. The signature is then used to expose a user facing api. When the user uses this api
       endpoint, the callback will get called
     - =POST "/status"= - sends a voluntary status update regarding an entity. Recieves a context
       which identifies the context in which this was called, the metadata of entity and its new
       status. This functionality is only exposed to the providers, since they are the only view
       Papiea has of the real world. 

     #+Name: provider-api-pc
     #+BEGIN_SRC go
       func (papieaApis papieaApiContext) providerFacingApi() err {
           // Registering Provider Facing APIs.
           api = papieaApis.api
           papieaPrefix = papieaApis.prefix
	
           api.post(papieaPrefix+"/on", func(req, res) {
               // Callback url is being generated by the papiea provider library and passed on the request.
               papieaApis.registerIntentfulCallback(req.signature, req.callbackUrl)
           })

           api.post(papieaPrefix+"/procedure", func(req, res) {
               // Callback url is being generated by the papiea provider library and passed on the request.
               papiea_apis.registerProceduralCallback(req.signature, req.callbackUrl)
           })

           // Status update is only exposed to providers. Users can't update status.
           api.post(papiea+"/status", func(req, res) {
               res.status(statusDb.updateStatus(req.uuid, req.status) ? 200 : 400)
               return res;
           })
       }


     #+END_SRC
**** User facing APIs
     
     #+Name: user-api-pc
     #+BEGIN_SRC go
       func (papiea papiea) userFacingApis() err {
           registeredProviders = papiea.providersDb.listProviders()

           for _, provider := range registeredProviders {
               for _, kind := range provider.kinds{
			
               }
           }
       }
     #+END_SRC
*** Change Spec
*** Update Status
*** SFS - Status Fields Signature
    When a spec change is submitted and successfully atomically swapped in, it is evaluated against
    the current status. The difference between this spec change and current status yields a Diff
    which is then evaluated using =Status Fields Signatures=. An SFS describes what changes in
    status needs to happen in order for the Diff to converge.

    This is a crucial element of the intent engine formalism, since it describes a way for the
    engine to "infer" which procedural actions are to be taken to complete an intentful
    specification.

    Here are a few examples of the proposed SFS syntax:
    1. =hosts.+{metadata.uuid}= - Matches when a new host entity (identified by =metadata.uuid=) has
       been added to the system. Typically this will the signature of a "create entity"
       function. 

    2. =hosts.-{metadata.uuid}= - Similar to the previous example, but this time the entity has been removed.
       
    3. =hosts.{metadata.uuid}.name= - Matches when an existing host is asking to rename. See the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

         new spec change: {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 4}
                           spec     {name "new name"                    << DIFF
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       In this example, after a successfully setting the new spec, the entity would look like this:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 4}               << Updated
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "new name"               << DIFF
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

       #+END_EXAMPLE

       We can see that the difference for the a particular host entity (as identified by the
       =metadata.uuid= value) is only in the =name= field. Thus, we want to find a function that
       knows how to transform the =name= status field. The engine will invoke the function that can
       resolve this diff.

    4. =hosts.{metadata.uuid}.networks.+{mac}= a handler that will get triggered when a new network
       is added to a vector found for key "networks", where the new network is identified by a field
       called "mac". Lets see this in the example, considering the =current host entity= as before:
       #+BEGIN_EXAMPLE
         new spec change: {metadata {uuid "1234"
                                     kind "host"
                                     specVersion 4}
                           spec     {name "a"
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}
                                               {mac "2.2.2.2.2"     << DIFF
                                                cidr "10.1.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       And we can see that once this new spec change will be atomically swapped in, there will be a
       diff only in the =network= key, and a new item (identifiable by =mac=) will be added. We need
       to invoke a function that knows how to add new networks to existing hosts.

    5. =hosts.{metadata.uuid}.networks.{mac}.cidr= Similar to the previous one, however, in here we
       are listening on a change of the =cidr= field inside an already existing network identifiable
       by =mac=. Now a function that changes cidr values for existing networks in existing hosts
       whould be invoked.
       
    6. =hosts.{metadata.uuid}.field_a, hosts.{metadata.uuid}.field_b= this is an example of a
       compound signature, which is matched when a single spec change has caused a difference in
       both =field_a= and =field_b= of a particular host, identified by =metadata.uuid=
       - We could revise the syntax to be something like =hosts.{metadata.uuid}.[field_a, field_b]= instead

    7. =hosts.{metadata.uuid}.field_a, hosts.{metadata.uuid}.inner.{id}.field_b= this is another
       example of a more complex signature, where a single spec change causes a difference in both
       =field_a= and =field_b= which is a compound object that lies inside a vector =inner= which is
       identified by =id=. Lets consider the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}
                                spec     {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}}

         new spec change: {metadata {uuid "1234"
                                          kind "host"
                                          spec_version 4}
                            spec     {field_a "another val 1"               << DIFF
                                      inner   [{id 1
                                                field_b "another val 2"}]}} << DIFF

       #+END_EXAMPLE

       In this example, the SFS would match the spec change if it gets atomically swapped in
       properly. This syntax could also be revised to something like
       =hosts.{metadata.uuid}.[field_a, inner.{id}.field_b]=
       

**** Formal syntax of SFS
     The following is a formal syntax describing SFS:

     #+BEGIN_EXAMPLE
      S                = (Single-diff ',')* Single-diff
      Single-diff      = Same-path Terminal
      Terminal         = Different-field | Added-by-field | Removed-by-field
      Same-path        = ((Key '.') | Id-into-vector)+
      Id-into-vector   = '{' (Key '.')* Key '}' '.'
      Key              = #'[a-zA-Z_]+'
      Added-by-field   = '+' Id-field
      Removed-by-field = '-' Id-field
      Id-field         = '{' (Key '.')* Key '}'
      Different-field  = Key
    #+END_EXAMPLE
    
**** SFS struct
    #+Name: sfs-signature
    #+BEGIN_SRC go
      type sfsSignature struct {
          signature string
          parsedSignatureAst ...
      }
    #+END_SRC
*** Procedures Signatures
    Procedures are functions that providers can expose directly to an entity. These functions are
    not intentful by design, and usually cannot be expressed in terms of a spec change.

    For example, consider asking a host to reboot. The =Power= status of a host can either be =On=
    or =Off=. However, a reboot is not a state of a machine, its a transition of the power state,
    and thus cannot be expressed in terms of a desired state. It is said to be a =Procedure= that is
    exposed on the host kind.

    Similarly to SFS, procedures are also registring based on a signature, lets see an example:
    
    - =hosts/{metadata.uuid}/reboot= - This signature refers to a =host= kind, will look a particular
      host up by matching the given uuid to the =metadata.uuid= field of the host, and expose a
      function called =reboot=. Seeing this signature will cause the engine to add a the following new api end point for the
      host kind:
      #+BEGIN_EXAMPLE
      POST "/hosts/{uuid}/reboot" 
      #+END_EXAMPLE
  
      Where ={uuid}= value will be matched against the host's =metadata.uuid=. Once a POST request for this
      route has been received by the user, the request will be forwarded to the callback url provided at registration time.
    
**** Procedure Signature struct
     #+Name: procedure-signature
     #+BEGIN_SRC go
       type procedureSignature struct {
           signature string
           parsedSignatureAst ...
       }
     #+END_SRC
*** Understanding Deltas
**** Matching SFSs to Deltas
**** Determining Order
*** Provider
    This section describes provider handling on Papiea's side. For the provider itself, please see [[*Provider Library][Provider Library]].
    
    As described in [[*Providers facing APIs][Providers facing APIs]] section, providers interact with the intetful engine by
    registring callbacks for two styles of actions:
    - Intentful actions - which are executed by analyzing their [[*SFS - Status Fields Signature][Status Fields Signature]]
    - Procedural actions - which are executed by a user interaction

    The following interface defines the registration mechanism for both kinds of actions:

    #+Name: provider-handler-interface
    #+BEGIN_SRC go
      type provider_callbacks interface {
          registerIntentfulCallback(sig sfsSignature, callbackUrl string) err
          registerProceduralCallback(sig procedureSignature, callbackUrl string) err
      }
    #+END_SRC

    The following pseudocode describes how these may be implemented:

    #+Name: provider-handler-pc
    #+BEGIN_SRC go
      func (api_ctx papieaApiContext) registerIntentfulCallback(sig sfsSignature, callbackUrl string) err {
          deltaAnalyzer.register(sig, callbackUrl)
      }

      func (api_ctx papiea_api_ctx) registerProceduralCallback(sig procedureSignature, callbackUrl string) err {
          procedures.register(sig, callbackUrl)
      }
    #+END_SRC
*** RBCA
*** Scalability and Reliability
**** Leader election
**** Fault tolerance
***** Dead Papiea Instance
***** Dead Provider
*** Cleanup process
    - automatic deletion?
*** Auditing
** Intentful Tasks
   Tasks are intentful in our intent engine. This means that a task defines an intent to "get
   notified when a certain change request has completed". 

   A new task is started in the context of providing a new spec change. Since a spec change is
   atomically swapped by the engine, a task for a particular spec change may fail simply for not
   being able to atomically perform the swap (such as CAS failures in certain atomicity
   models). Once a spec change has been properly and atomically swapped in, the task registers a
   status change listener using [[*SFS - Status Fields Signature][SFS - Status Fields Signature]]. It will listen on all the fields that
   the spec change has requested to change. On every field, the following actions can happen:
   1. The field will get updated to the value that the spec change was requesting
      - Once this happens, this field is marked as successfully being fulfilled, the context of the
        status change may be logged for later auditing and the SFS for this field is stopped
   2. The field will get updated to a value that is *other* than the spec change was requesting
      - If this happens, the task will look to see if the spec version of the entity has increased
        - If it has, this field will be marked as *outdated* and teh SFS for this field is
          stopped. A reference to the outdating spec change may be maintained for later auditing.
        - If it still has the same spec version as the task, the task will not get updated
   
   Using this scheme, the task is said to be complete if there are no more active SFS listeners. It
   may be completed in three ways:
   1. Completed Successfully - All fields were set to the spec value at some point after the spec
      change was issued
   2. Completed Partially - Some fields were set to the spec value, and some were not due to a newer
      spec version
   3. Failed - non of the fields was changed to the given spec values, and there is already a newer
      spec version
   
   As long as there are still active SFS listeners in the task, it will be *pending*. It can show
   progress in terms of how many fields are left of the total fields. The intent engine will have to
   query pending tasks periodically to see if work has to be restarted.
   
   #+Name: task-pc
   #+BEGIN_SRC go
     func () newTask() {
	
     }
   #+END_SRC
** Provider Library
*** Define Entity Model
**** YAML
**** CRUD
*** Initialize
*** Callback Mechanism
*** Running Effect Validator
*** Status Changes Handlers
**** Registring
**** Running using context
*** Procedures
**** Registring
**** Running using context
*** Example Provider

* Full files
** /src/papiea/engine/core.go
   #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/core.go :exports code :mkdirp yes
   // All our structs and interfaces:
   
   // Untyped json for now. We should probably use some better library for that:
   <<untyped-json-type>>

   // Spec, status and metadata:
   <<spec-struct>>
   <<status-struct>>
   <<metadata-struct>>
   
   // Kind and providers:
   <<kind-struct>>
   <<provider-desc-struct>>

   // Define our database interfaces:
   <<stataus-db-interface>>
   <<spec-db-interface>>
   <<providers-db-interface>>
   
   // Services interfaces:
   <<task-interface>>

   // Provider APIs signatures.
   // Status Fields Signatures:
   <<sfs-signature>>

   // Procedure Signatures:
   <<procedure-signature>>

   // Provider handlers:
   <<provider-handler-interface>>

   // Papiea:
   <<initialize-papiea>>
   <<papiea_api_ctx>>
   <<papiea_apis>>
   
   #+END_SRC
** /src/papiea/engine/server.go
  #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/server.go :exports code :mkdirp yes
    #import stuff

    // Initialize Papiea.
    <<initialize-papiea-pc>>

    // Admin Facing APIs:
    <<admin-api-pc>>
    
    // Provider Facing APIS:
    <<provider-api-pc>>
    
    // User Facing APIs:
    <<user-api-pc>>
  #+END_SRC
  
** /src/papiea/engine/provider.go 
   #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/provider.go :exports code :mkdirp yes
   // Provider handler registration:
   <<provider-handler-pc>>
   #+END_SRC

** /src/papiea/engine/tasks.go
   #+BEGIN_SRC go :noweb yes :tangle src/papiea/engine/tasks.go :exports code :mkdirp yes
   // Provider handler registration:
   <<task-pc>>
   #+END_SRC


* Last notes
  - I followed [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][this tutorial]] for generating the source files through this org-mode.
